"""
Integration per lineage
"""
from pathlib import Path
import numpy as np
import pandas as pd
from snakemake.utils import Paramspace

from utils.misc import all_but, unique_dataframe
from utils.config import get_hyperparams, get_resource, get_params_from_config, set_defaults, get_datasets_for_module, get_for_dataset
from utils.wildcards import expand_per, get_params, get_wildcards, wildcards_to_str
from utils.environments import get_env


module_name = 'integration'
config = set_defaults(config, module_name)
image_dir = Path(config['images']) / f'{module_name}_per_lineage'
out_dir = Path(config['output_dir']) / f'{module_name}_per_lineage'
Path(out_dir).mkdir(parents=True, exist_ok=True)

hyperparams_df = get_hyperparams(config,module_name=module_name)
# write hyperparameter mapping
unique_dataframe(
    hyperparams_df[['method', 'hyperparams', 'hyperparams_dict']]
).to_csv(out_dir / 'hyperparams.tsv', sep='\t', index=False)

# get parameters
parameters = pd.read_table(workflow.source_path('params.tsv'))
parameters['output_type'] = parameters['output_type'].str.split(',')
parameters = get_params_from_config(
    config=get_datasets_for_module(config, module_name),
    module_name=module_name,
    config_params=['methods', 'label', 'batch', 'lineage', 'norm_counts', 'raw_counts'],
    wildcard_names=['dataset', 'method', 'label', 'batch', 'lineage_key', 'norm_counts', 'raw_counts'],
    defaults=config['defaults'],
    explode_by=['method', 'lineage_key', 'batch'],
).merge(parameters,on='method')
parameters['lineage_key'] = parameters['lineage_key'].astype(str)

# subset to datasets that have lineage defined
parameters = parameters[
    (parameters['lineage_key'] != 'None') & (parameters['lineage_key'].notna())
].reset_index(drop=True)

# add hyperparams
parameters = parameters.merge(
    hyperparams_df,
    on=['dataset', 'method'],
    how='left'
)

wildcard_names = ['dataset', 'batch', 'label', 'method', 'hyperparams', 'lineage_key']
paramspace = Paramspace(
    parameters[wildcard_names],
    filename_params=['method', 'hyperparams', 'lineage_key'],
    filename_sep='--',
)

wildcard_constraints:
    dataset='\w+',
    method='\w+',
    batch='((?![/]).)*',
    label='((?![/]).)*',
    hyperparams='((?![/]).)*',
    lineage_key='((?![/]).)*',


module integration:
    snakefile: "../../integration/rules/rules.smk"
    config: config

module clustering:
    snakefile: "../../clustering/rules/rules.smk"
    config: config

module preprocessing:
    snakefile: "../../preprocessing/rules/rules.smk"
    config: config

module common:
    snakefile: "../common/Snakefile"
    config: config

use rule * from common as common_ *


include: 'rules/split_lineage.smk'

split_lineage_suffix = 'lineage~{lineage}.zarr'

def get_checkpoint_output(checkpoint, **kwargs):
    return Path(checkpoint.get(**kwargs).output[0])


def get_lineages(**wildcards):
    checkpoint_output = get_checkpoint_output(checkpoints.split_lineage, **wildcards)
    return glob_wildcards(str(checkpoint_output / split_lineage_suffix)).lineage


def collect_lineages(wildcards, pattern):
    return {
        lineage: expand(pattern,lineage=lineage,**wildcards)
        for lineage in get_lineages(**wildcards)
    }

include: 'rules/preprocessing.smk'
include: 'rules/integration.smk'
# include: 'rules/benchmark.smk'
include: 'rules/umap.smk'
include: 'rules/clustering.smk'


rule merge_lineage:
    input:
        unpack(lambda w: collect_lineages(w, rules.integration_per_lineage_postprocess.output.zarr))
    output:
        zarr=directory(out_dir / 'per_lineage' / 'merge' / paramspace.wildcard_pattern / 'lineages.h5mu.zarr'),
    conda:
        get_env(config, 'scanpy')
    resources:
        partition=get_resource(config,profile='cpu',resource_key='partition'),
        qos=get_resource(config,profile='cpu',resource_key='qos'),
        mem_mb=get_resource(config,profile='cpu',resource_key='mem_mb'),
    script:
        'scripts/merge_anndata.py'


rule run_all:
    input:
        expand(
            rules.merge_lineage.output,
            zip,
            **parameters.query('lineage_key != "None"')[wildcard_names].to_dict('list')
        )


rule all:
    input:
        rules.run_all.input,
        rules.cluster_all.input,
        rules.umaps_all.input,
    default_target: True


rule dependency_graph:
    input:
        expand(
            rules.common_dependency_graph.input,
            images=config['images'] + f'/{module_name}',
            target='all'
        )
